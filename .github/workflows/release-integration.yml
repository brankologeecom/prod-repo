name: Release new version of the integration

on:
  workflow_dispatch:
    inputs:
      source_repo:
        description: "Owner/Repo of source (Repo A), e.g. Org/source-repo"
        required: true
        default: "Org/source-repo"
      source_ref:
        description: "Ref in Repo A to pull (branch, tag, or commit SHA)"
        required: true
        default: "main"
      target_repo:
        description: "Owner/Repo of target (Repo B), e.g. Org/target-repo"
        required: true
        default: "brankologeecom/prod-repo"
      tag_name:
        description: "Tag to create in Repo B (e.g., v1.2.3)"
        required: true
        default: "v1.0.0"
      commit_message:
        description: "Commit message for Repo B"
        required: false
        default: "Promote from Repo A via DevOps"
      git_user_email:
        description: "Git user.email for commits"
        required: false
        default: "ci-bot@users.noreply.github.com"
      git_user_name:
        description: "Git user.name for commits"
        required: false
        default: "DevOps CI Bot"
      release_title:
        description: "Release title in Repo B (defaults to tag if empty)"
        required: false
        default: ""
      release_notes:
        description: "Release notes"
        required: false
        default: "Automated release via DevOps"

jobs:
  promote:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    env:
      TARGET_BRANCH: master
      ARTIFACT_NAME: artifact.zip
      VCS_ACCESS_TOKEN: ${{ secrets.VCS_ACCESS_TOKEN }}
      GH_TOKEN: ${{ secrets.VCS_ACCESS_TOKEN }}
      GIT_TERMINAL_PROMPT: "0"   # nikad ne traži interaktivno korisnika/lozinku

    steps:
      # Ne zadržavaj GITHUB_TOKEN kredencijale; koristimo PAT svuda
      - uses: actions/checkout@v4
        with:
          persist-credentials: false

      # Ukloni globalni .extraheader koji bi gurnuo GITHUB_TOKEN
      - name: Remove default GitHub auth header
        run: |
          git config --global --unset-all http.https://github.com/.extraheader || true

      - name: Install prerequisites
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y zip rsync gh git-lfs jq
          gh --version
          git lfs install --system

      - name: Configure git
        run: |
          set -e
          git config --global user.email "${{ github.event.inputs.git_user_email }}"
          git config --global user.name  "${{ github.event.inputs.git_user_name }}"
          git config --global advice.addEmbeddedRepo false
          git config --global pull.rebase true
          git config --global rebase.autoStash true

      - name: Preflight — verify token & repo access
        env:
          TGT: ${{ github.event.inputs.target_repo }}
        run: |
          set -e
          gh auth status
          gh repo view "$TGT" --json name,visibility,isPrivate,defaultBranchRef -q '{name,visibility,isPrivate,defaultBranchRef:.defaultBranchRef.name}'
          gh api -X GET "repos/$TGT" --jq '.permissions'
          gh repo view "$TGT" --json viewerPermission -q .viewerPermission

      - name: Clone Repo A (source)
        run: |
          set -e
          SRC="${{ github.event.inputs.source_repo }}"
          REF="${{ github.event.inputs.source_ref }}"
          git clone --no-tags --depth 1 --branch "$REF" \
            "https://x-access-token:${VCS_ACCESS_TOKEN}@github.com/${SRC}.git" repoA || (
              echo "Ref '$REF' not found shallow; fetching full history..."
              git clone "https://x-access-token:${VCS_ACCESS_TOKEN}@github.com/${SRC}.git" repoA
              cd repoA && git fetch --all --tags && git checkout "$REF"
          )

      - name: Build package content
        run: |
          set -e
          mkdir -p build
          rsync -a --delete repoA/ build/
          rm -rf build/.git build/.github || true
          rm -f build/.gitignore build/.gitattributes || true
          echo "Built from ${{ github.event.inputs.source_repo }}@${{ github.event.inputs.source_ref }} on $(date -u)" > build/BUILD_INFO.txt

      - name: Package artifact
        run: |
          set -e
          cd build
          zip -r "../${ARTIFACT_NAME}" .
          cd -
          ls -lah "${ARTIFACT_NAME}"

      - name: Push changes directly to target branch (explicit PAT URL for all network ops)
        run: |
          set -e
          TGT="${{ github.event.inputs.target_repo }}"
          BR="${TARGET_BRANCH}"
          MSG="${{ github.event.inputs.commit_message }}"
          REMOTE_URL="https://x-access-token:${VCS_ACCESS_TOKEN}@github.com/${TGT}.git"

          # 1) Kloniraj target repo sa PAT URL-om
          git clone "${REMOTE_URL}" repoB
          cd repoB
          git config --global --add safe.directory "$(pwd)"

          # 2) Uvek poravnaj lokalnu granu tačno na poslednji remote tip (bez oslanjanja na 'origin')
          git fetch "${REMOTE_URL}" "${BR}" --prune || true
          if [ -s .git/FETCH_HEAD ]; then
            git checkout -B "${BR}"
            git reset --hard FETCH_HEAD
          else
            # remote grana ne postoji - započni novu lokalnu granu
            git checkout -B "${BR}"
          fi

          # 3) Primeni build sadržaj
          rsync -a --delete ../build/ ./
          git status --porcelain || true

          git add -A
          if git diff --cached --quiet; then
            echo "No changes detected; nothing to push."
            exit 0
          fi

          git commit -m "$MSG"

          # 4) Pokušaj push uz do 3 rebase retry-ja; sve mrežne komande koriste eksplicitni PAT URL
          tries=0
          max_tries=3
          while true; do
            echo "== Push attempt $((tries+1))/$max_tries =="
            set +e
            git push "${REMOTE_URL}" HEAD:refs/heads/"${BR}"
            rc=$?
            set -e
            if [ $rc -eq 0 ]; then
              echo "Push succeeded."
              break
            fi

            if [ $tries -ge $((max_tries-1)) ]; then
              echo "::error::Push failed after $max_tries attempts (non-fast-forward)."
              echo "Tip: branch protection requires PR or remote is moving too fast."
              exit 1
            fi

            echo "Remote advanced; fetching via PAT URL and rebasing onto latest ${BR}…"
            git fetch "${REMOTE_URL}" "${BR}" --prune
            # Rebase na FETCH_HEAD (eksplicitno, bez 'origin')
            set +e
            git rebase FETCH_HEAD
            REBASE_RC=$?
            set -e
            if [ $REBASE_RC -ne 0 ]; then
              echo "::error::Rebase conflict. Cannot auto-resolve in push-only mode."
              exit 1
            fi

            tries=$((tries+1))
          done

      - name: Create or update release in target repo
        run: |
          set -e
          REPO="${{ github.event.inputs.target_repo }}"
          TAG="${{ github.event.inputs.tag_name }}"
          TITLE="${{ github.event.inputs.release_title }}"
          NOTES="${{ github.event.inputs.release_notes }}"
          [ -z "$TITLE" ] && TITLE="$TAG"

          if gh release view "$TAG" --repo "$REPO" >/dev/null 2>&1; then
            gh release upload "$TAG" "${ARTIFACT_NAME}" --repo "$REPO" --clobber
          else
            gh release create "$TAG" "${ARTIFACT_NAME}" \
              --repo "$REPO" \
              --title "$TITLE" \
              --notes "$NOTES" \
              --target "${TARGET_BRANCH}"
          fi
